<?php
/**
 * Indicia, the OPAL Online Recording Toolkit.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses/gpl.html.
 *
 * @package Indicia
 * @subpackage Libraries
 * @author  Indicia Team
 * @license http://www.gnu.org/licenses/gpl.html GPL
 * @link    http://code.google.com/p/indicia/
 */

/**
* <h1>Report provider</h1>
* <p>The report provider allows for accession of predefined or provided reports.</p>
*
* @package Indicia
* @subpackage Controller
* @license http://www.gnu.org/licenses/gpl.html GPL
* @author Nicholas Clarke <xxx@xxx.net> / $Author$
* @copyright xxxx
* @version $Rev$ / $LastChangedDate$
*/

/**
* Class to control accession to reports generated by the Indicia core.
*
* A report will have a number of parameters that need to be completed by the requester. Because
* this interface is designed to be used by both the core module and the site module, we cannot
* directly request this information. As such, we do the following:
* <ol>
* <li> Grab the report and parse it for parameters. </li>
* <li> Send a response back to the requester, inviting them to fill in the parameters. This
* reponse will include the id generated in step 3. </li>
* <li> The requester sends back the requested parameters, which are checked against the cache to
* ensure they're all there. If not, repeat these steps. </li>
* <li> The core reparses the report, merges the parameters in and executes the query
* against the core database. Results are formatted and returned to the requester. </li>
* </ol>
*
* We should also allow submission of parameters with the report, or a combination of this and
* requesting them as we go.
*
* We use XML reports roughly in keeping with the standard defined in Recorder (though with limited
* complexity compared to recorder's options). However, this module is written to easily allow
* reports written in other formats, and in keeping with the rest of the project we use JSON as our
* principal language for network communication - e.g. for parameter requests, delivery, and other
* messages.
*/

class ReportEngine {

  private $report;
  private $reportFormat;
  private $response;
  private $query;
  private $reportReader;
  // Of the form name => array('type' => type, 'display' => display, 'description' => desc)
  private $expectedParams;
  private $providedParams;
  private $localReportDir;
  const rowsPerUpdate = 50;
  private $websiteIds;
  private $userId = null;
  private $sharingMode='reporting';
  private $doneStandardParamJoins = array();
  /**
   * @var array List of filters to put in HAVING
   */
  private $having = [];

  /**
   * @var array A list of additional columns identified from custom attribute parameters.
   */
  private $attrColumns = array();

  /**
   * @var array A list of the actual custom attributes, along with a link to the cols they include.
   */
  private $customAttributes = array();

  /**
   * @var array A list mappings from known custom attribute captions to the IDs.
   */
  private $customAttributeCaptions = array();

  /**
   * @var integer If the record count has been queried, store it so we don't ask twice.
   */
  private $recordCountResult;

  /**
   * Constructor
   * @param array $websiteIds List of websites you are loading the report for. Normally a single, but can be a list
   * when logged in on the warehouse.
   * @param integer $userId ID of the user loading the report
   * @param $db object Database object to run the report. Default null, which will create a new connection using the report
   * user configuration
   */
  public function __construct($websiteIds = null, $userId = null, $db = null)
  {
    $this->websiteIds = $websiteIds;
    $this->userId = $userId;
    $this->localReportDir = Kohana::config('indicia.localReportDir');
    $this->reportDb = $db === null ? new Database('report') : $db;
  }

  /**
   * Retrieve all available reports, as a nested associative array.
   */
  public function reportList() {
    $reports = $this->internalReportList(Kohana::config('indicia.localReportDir'), '/');
    foreach (Kohana::config('config.modules') as $path) {
      if (is_dir("$path/reports"))
        $reports = array_replace_recursive($reports, $this->internalReportList("$path/reports", '/'));
    }
    return $reports;
  }

  private function internalReportList($root, $path) {
    $files = array();
    $fullPath = "$root$path";
    if (!is_dir($fullPath))
      throw new Exception("Failed to open reports folder ".$fullPath);
    $dir = opendir($fullPath);

    while (false !== ($file = readdir($dir))) {
      // The following skips the tmp folder in the report root as this is used for provided reports.
      if ($file != '.' && $file != '..' && $file != '.svn' && is_dir("$fullPath$file") &&
          ($file !== 'tmp' || $path!=='/')) {
        $folderInfo = array(
          'type' => 'folder',
          'content' => $this->internalReportList($root, "$path$file/")
        );
        if (file_exists("$fullPath$file/readme.txt")) {
          $folderInfo['description'] = file_get_contents("$fullPath$file/readme.txt");
        }
        $files[$file] = $folderInfo;
      } elseif (substr($file, -4)=='.xml') {
        $metadata = XMLReportReader::loadMetadata("$fullPath$file");
        $file = basename($file, '.xml');
        $reportPath = ltrim("$path$file", '/');
        $reportInfo = array(
          'type'=>'report',
          'title'=>$metadata['title'],
          'description'=>$metadata['description'],
          'path'=>$reportPath
        );
        if (!empty($metadata['standard_params'])) {
          $reportInfo['standard_params'] = $metadata['standard_params'];
        }
        if (!empty($metadata['featured'])) {
          $reportInfo['featured'] = $metadata['featured'];
        }
        $files[$file] = $reportInfo;
      }
    }
    closedir($dir);
    return $files;
  }

  /**
  * Access the report - probably we will use routing to direct /report directly to /report/access
  * We can specify a request in a number of ways:
  * <ul>
  * <li> Predefined report on the core module. </li>
  * <li> Predefined report elsewhere (URI given). </li>
  * <li> Report passed with the query. </li>
  * </ul>
  * We also need to perform authentication at a read level for the data we're trying to access
  * (this might be fun, given the low level that the reports run at).
  *
  * @param string $report Name of the report file to run.
  * @param string $reportSource Source of the report, either local or remote.
  * @param string $reportFormat Format of the report file. Currently only xml report file formats are supported.
  * @param array $params Associative array of report parameters.
  */
  public function requestReport($report = null, $reportSource = 'local', $reportFormat = null,  $params = array())
  {
    $this->reportFormat = $reportFormat;
    $this->providedParams = array_merge(
      array('training' => 'false'),
      $params
    );
    // is the default sharing mode of "reporting" being overridden?
    if (isset($this->providedParams['sharing']))
      $this->sharingMode = $this->providedParams['sharing'];
    Kohana::log('debug', "Received request for report: $report, source: $reportSource");
    if ($reportSource == null) {
      $reportSource='local';
    }
    if ($report == null)
    {
      return array
      (
      'error' => 'Report parameter is null',
      'report' => $report,
      'source' => $reportSource
      );
    }

    switch ($reportSource)
    {
      case 'local':
        $this->fetchLocalReport($report);
        break;
      case 'remote':
        $this->fetchRemoteReport($report);
        break;
      case 'provided':
        $this->fetchProvidedReport($report);
        break;
      default:
        // ERROR
        return array('error' => 'Invalid report source specified');
    }

    // Now we switch based on the report format.
    switch ($this->reportFormat)
    {
      case 'xml':
        // allow the list of columns to be returned to be passed as a parameter
        $cols = empty($this->providedParams['columns']) ? array() : explode(',', $this->providedParams['columns']);
        $this->reportReader = new XMLReportReader($this->report, $this->websiteIds, $this->sharingMode, $cols);
        $this->reportReader->loadStandardParams($this->providedParams, $this->sharingMode);
        break;
      default:
        return array('error' => 'Unknown report format specified: '. $this->reportFormat);
        // No known report specified - return some error
        // TODO
    }
    // What parameters do we expect?
    $this->expectedParams = $this->reportReader->getParams();
    // some have defaults in the report XML file
    $this->providedParams = array_merge($this->reportReader->defaultParamValues, $this->providedParams);

    // Special case params for limit, offset, ordeby and sortdir must be 
    // checked to prevent SQL injection.
    // Limit and Offset must be integers.
    // Sortdir must be ASC|DESC.
    // Orderby must be a single valid identifer.
    $check_params = array(
      'limit' => array('type' => 'int', 'regex' => NULL),
      'offset' => array('type' => 'int', 'regex' => NULL),
      'sortdir' => array('type' => 'str', 'regex' => '/^(ASC|DESC)$/i'),
      'orderby' => array('type' => 'str', 'regex' => '/^[A-Z_][A-Z0-9_]*$/i'),
    );
    foreach ($check_params as $param => $check)
    if (isset($this->providedParams[$param])) {
      $value = $this->providedParams[$param];
      $checked_value = security::checkParam($value, $check['type'], $check['regex']);
      if ($checked_value !== FALSE) {
        $this->$param = $checked_value;
      }
      else {
        Kohana::log('alert', "Invalid parameter, $param, with value '$value' in request for report, $report.");
        throw new Exception('Invalid request.');
      }
    }
    else {
      // Potential for DoS if limit is null and results are massive.
      $this->$param = NULL;
    }
    
    return array(
      'description' => $this->reportReader->describeReport(ReportReader::REPORT_DESCRIPTION_BRIEF),
      'content' => $this->compileReport()
    );
  }

  /**
   * Requests the report's metadata including column and parameter information.
   * @param $report
   * @param bool $includeUnusedParameters Set to true to force all parameters to be
   * included, not just those that are in use for the current report call.
   * @return array
   */
  public function requestMetadata($report, $includeUnusedParameters = false) {
    $this->fetchLocalReport($report);
    $this->reportReader = new XMLReportReader($this->report, $this->websiteIds);
    $this->providedParams = array();
    if ($includeUnusedParameters) {
      $params = $this->reportReader->getAllParams();
    } else {
      $this->reportReader->loadStandardParams($this->providedParams, $this->sharingMode);
      $params = $this->reportReader->getParams();
    }
    $this->prepareColumns();
    $r = array(
      'columns' => $this->columns,
      'parameters' => $params
    );
    return $r;
  }

  /**
  * Checks parameters and returns request if they're not all there, else compiles the report.
  *
  * @return array Array containing columns and data.
  */
  private function compileReport()
  {
    // Do we need any more parameters?
    $unpopulatedParams = array_diff_key($this->expectedParams, $this->providedParams);
    if (isset($this->providedParams['paramsFormExcludes'])) {
      $includedParams = array_diff_key($this->expectedParams,
          array_fill_keys(json_decode($this->providedParams['paramsFormExcludes']), ''),
          // never ask for params with defaults in the params form.
          $this->reportReader->defaultParamValues);
    }
    if (!empty($unpopulatedParams))
    {
      // Send a request for further parameters back to the client. If the request specified the list of parameters to drop
      // in the paramsFormExcludes parameter, then the list of parameters is always the ones that are not excluded. Else
      // the list of parameters is the list of unpopulated parameters.
      $res = array('parameterRequest' => isset($includedParams) ? $includedParams : $unpopulatedParams);
      return $res;

    }
    else
    {
      // Okay, all the parameters have been provided.
      $this->mergeCountQuery();
      $this->mergeQuery();
      if ($this->limit===0 || $this->limit==='0' || (isset($_REQUEST['wantRecords']) && $_REQUEST['wantRecords']===0)) {
        // optimisation for zero limited queries
        $data=array();
      }
      else {
        $this->executeQuery();
        $data = $this->response->result_array(FALSE);
      }
      $this->prepareColumns();
      $this->post_process($data);
      $r = array(
        'columns'=>$this->columns,
        'records'=>$data
      );
      if (isset($includedParams) && count($includedParams)>0)
        $r['parameterRequest'] = $includedParams;
      return $r;
    }
  }

  public function record_count() {
    if (isset($this->countQuery) && $this->countQuery!==null) {
      if (isset($this->recordCountResult))
        return $this->recordCountResult;
      // If there is a HAVING clause in the query, then we cannot count aggregate queries in the normal way which is to
      // strip the group by and count the appropriate fields. We have to run the full grouped query with the HAVING
      // clause included, then use a subquery to count the rows.
      if (!empty($this->having)) {
        $unlimitedQuery = preg_replace('/LIMIT \d+/i', '', $this->query);
        $this->countQuery = "SELECT count(*) FROM ($unlimitedQuery) AS subquery";
      }
      $tm = microtime(true);
      $r = $this->reportDb->query($this->countQuery)->result_array(FALSE);
      $tm = microtime(true) - $tm;
      if ($tm>5) {
        kohana::log('alert', "Count query took $tm seconds.");
        kohana::log('alert', $this->report);
        kohana::log('alert', $this->countQuery);
      }
      // query could return no rows, in which case return zero. Or multiple if counting several UNIONED queries.
      $count=0;
      foreach ($r as $row)
        $count += $row['count'];
      $this->recordCountResult = $count;
      return $count;
    } else {
      return false;
    }
  }

  /**
   * Obtain the set of columns from the report reader on demand, so it is only called once.
   */
  private function prepareColumns() {
    if (!isset($this->columns)) {
      $this->columns = array_merge(
         $this->reportReader->getColumns(),
         $this->attrColumns
      );
    }
  }
  /**
   * Takes the data and columns lists, and carries out any post query processing.
   * This includes vague date processing, and any other defined by the
   * report reader.
   */
  private function post_process(&$data) {
    $this->merge_attribute_data($data, $this->providedParams);

    $vagueDateProcessing = $this->getVagueDateProcessing();
    $downloadProcessing = $this->getDownloadDetails();
    if($vagueDateProcessing) {
      $this->add_vague_dates($data);
    }
    if($downloadProcessing->mode == 'INITIAL' || $downloadProcessing->mode == 'CONFIRM' ||$downloadProcessing->mode == 'FINAL') {
      $this->setDownloaded($data, $downloadProcessing);
    }
  }

  private function getVagueDateProcessing() {
    $vagueDateProcessing = $this->reportReader->getVagueDateProcessing();
    foreach ($this->providedParams as $name => $value) {
      if (!is_array($value))
        $vagueDateProcessing = preg_replace("/#$name#/", $value, $vagueDateProcessing);
    }
    return !($vagueDateProcessing == 'false');
  }

  private function getDownloadDetails() {
    $downloadProcessing = $this->reportReader->getDownloadDetails();
    foreach ($this->providedParams as $name => $value) {
      if (!is_array($value))
        $downloadProcessing->mode = preg_replace("/#$name#/", $value, $downloadProcessing->mode);
    }
    return $downloadProcessing;
  }


  /**
   * Takes the data and columns lists, and looks for a vague date column set.
   * If one is found, inserts a new column for the processed date string.
   */
  private function add_vague_dates(&$data) {
    $col_sets=array();
    $columnNames = array_keys($this->columns);
    // First find the additional plaintext columns we need to add
    foreach($this->columns as $col => $coldef) {
      if (isset($coldef['on_demand']) && $coldef['on_demand']==="true")
        continue;
      if (substr($col, -10)=='date_start') {
        $prefix=substr($col, 0, strlen($col)-10);
        // check that the report includes date_end and type
        if (in_array($prefix."date_end", $columnNames) && in_array($prefix."date_type", $columnNames)) {
          array_push($col_sets, $prefix);
          if (!in_array($prefix.'date', $columnNames)) {
            $this->columns[$prefix.'date'] = array(
              'display'=>'Date',
              'class'=>'',
              'style'=>'',
              'datatype'=>'date'
            );
          }
          // Hide the internal vague date columns, unless the report explicitly asks for them (in which case
          // autodef will not be true).
          if (!array_key_exists('autodef', $this->columns[$prefix.'date_start']) ||
              $this->columns[$prefix.'date_start']['autodef']==true) {
            $this->columns[$prefix.'date_start']['visible']='false';
          }
          if (!array_key_exists('autodef', $this->columns[$prefix.'date_end']) ||
              $this->columns[$prefix.'date_end']['autodef']==true) {
            $this->columns[$prefix.'date_end']['visible']='false';
          }
          if (!array_key_exists('autodef', $this->columns[$prefix.'date_type']) ||
              $this->columns[$prefix.'date_type']['autodef']==true) {
            $this->columns[$prefix.'date_type']['visible']='false';
          }
        }
      }
    }

    // Now we have identified the vague date columns to add, create data columns with the processed date
    // strings.
    $dataCount = count($data); // invariant
    foreach($col_sets as $col_set) {
      for ($r=0; $r<$dataCount; $r++) {
        $row=$data[$r];
        if (!empty($row[$col_set.'date_type'])) {
          try {
            $data[$r][$col_set . 'date'] = vague_date::vague_date_to_string(array(
              $row[$col_set . 'date_start'],
              $row[$col_set . 'date_end'],
              $row[$col_set . 'date_type']
            ));
          } catch (Exception $e) {
            kohana::log('error', 'Error in report vague date conversion: ' . $e->getMessage());
            $data[$r][$col_set . 'date'] = 'Invalid';
          }
        }
      }
    }
  }

  public function merge_attribute_data(&$data, $providedParams)
  {
    $dataCount = count($data); // invariant
    /* attributes are extra pieces of information associated with data rows. These can have multiple values within each field,
     * so do not lend themselves to being fetched by a extended join within the original SQL query.
     */
    /* loop through each table, looking for attribute definitions */
    $attributeDefns = $this->reportReader->getAttributeDefns();
    /* Attribute definitions included the query to run, and the field names to compare between each data array for matching */
    $vagueDateProcessing = $this->getVagueDateProcessing();
    foreach($attributeDefns as $attributeDefn){
        // Build an index of the report data indexed on the attribute: nb that the attribute data has been sorted in main_id order.
        $index = array();
        for ($r=0; $r<$dataCount; $r++) {
          if(!isset($index[$data[$r][$attributeDefn->parentKey]])){
            $index[$data[$r][$attributeDefn->parentKey]] = array($r);
          } else
            $index[$data[$r][$attributeDefn->parentKey]][] = $r;
        }
    	$subquery = $attributeDefn->query;
        foreach ($providedParams as $name => $value)
        {
          $subquery = preg_replace("/#$name#/", $value, $subquery);
        }
        $response = $this->reportDb->query($subquery);
        $attrData = $response->result_array(FALSE);
        $newColumns = array();
        // This makes some assumptions about the way the attribute data is stored within the DB tables.
        // Note that $attributeDefn->id is actually text, which means that the order of data in $row is actually the order in which the
        // attributes are encountered in the data set.
        // we assume that the attributes are ordered in blocks of each attribute ID, in the order that we wish them to appear in the report.
        foreach ($attrData as $row){
          // If this attribute row has not been encountered so far, make a new column for it, initialise to blank.
          if(!array_key_exists($row[$attributeDefn->id], $newColumns)){  // id is the column holding the attribute id.
            $newColName=$attributeDefn->columnPrefix.$row[$attributeDefn->id];
            $multiValue = ($row['multi_value'] == 't') && ($row["data_type"] != 'D') && ($row["data_type"] != 'V');
            $newColumns[$row[$attributeDefn->id]] = array(
                  'caption' => $row[$attributeDefn->caption],
                  'column' => $newColName,
                  'multi_value' => $multiValue);
            switch ($row["data_type"]) {
              case 'D':
              case 'V':
                $this->columns[$newColName."_date_start"] = array('display'=>$row[$attributeDefn->caption]." Start", 'class'=>'', 'style'=>'', 'autodef' => ($vagueDateProcessing && $attributeDefn->hideVagueDateFields == 'true'));
                $this->columns[$newColName."_date_end"] = array('display'=>$row[$attributeDefn->caption]." End", 'class'=>'', 'style'=>'', 'autodef' => ($vagueDateProcessing && $attributeDefn->hideVagueDateFields == 'true'));
                $this->columns[$newColName."_date_type"] = array('display'=>$row[$attributeDefn->caption]." Type", 'class'=>'', 'style'=>'', 'autodef' => ($vagueDateProcessing && $attributeDefn->hideVagueDateFields == 'true'));
                if($vagueDateProcessing){  // if vague date processing enable for the report, add the extra column.
                  $this->columns[$newColName."_date"] = array('display'=>$row[$attributeDefn->caption]." Date", 'class'=>'', 'style'=>'');
                }
                for ($r=0; $r<$dataCount; $r++) {
                  $data[$r][$newColName.'_date_start'] = '';
                  $data[$r][$newColName.'_date_end'] = '';
                  $data[$r][$newColName.'_date_type'] = '';
                  $data[$r][$newColName.'_date'] = '';
                }
                break;
              case 'L':
                // Lookup
                if(isset($attributeDefn->meaningIdLanguage))
                  $termResponse = $this->reportDb->query("select tt.meaning_id as id, t.term from terms t, termlists_terms tt, languages l".
                  										 " where tt.termlist_id =".$row["termlist_id"].
                  										 " and tt.term_id = t.id ".
                  										 " and t.language_id = l.id ".
                  										 " and t.deleted=FALSE ".
                  										 " and tt.deleted = FALSE ".
                  										 " and l.deleted=FALSE ".
                  										 ($attributeDefn->meaningIdLanguage== "preferred" ?
                  											" and tt.preferred = true " :
                  											" and l.iso = '".$attributeDefn->meaningIdLanguage."'").
                  										 "ORDER by tt.meaning_id;");
                else
                  $termResponse = $this->reportDb->query("select tt.id, t.term from terms t, termlists_terms tt where tt.termlist_id =".$row["termlist_id"]." and tt.term_id = t.id and t.deleted=FALSE and tt.deleted = FALSE ORDER by tt.id;");
                $newColumns[$row[$attributeDefn->id]]['lookup'] = $termResponse->result_array(FALSE);
                // allow follow through so Lookup follows normal format of a singular field.
              default:
                $this->columns[$newColName] = array('display'=>$row[$attributeDefn->caption], 'class'=>'', 'style'=>'');
                for ($r=0; $r<$dataCount; $r++) {
                  $data[$r][$newColName] = $multiValue ? array() : '';
                }
                break;
            }
          }
          $column = $newColumns[$row[$attributeDefn->id]]['column'];
          switch ($row["data_type"]) {
            case 'L':
              $value = $row['int_value']; // default value is int value
              foreach($newColumns[$row[$attributeDefn->id]]['lookup'] as $lookup){
                if($value == $lookup["id"]){
                  $value = $lookup['term'];
                  break;
                }
              }
              if(isset($index[$row[$attributeDefn->main_id]]))
                foreach($index[$row[$attributeDefn->main_id]] as $r)
                  $this->mergeColumnData($data[$r][$column], $value);
              break;
            case 'I':
              if(isset($index[$row[$attributeDefn->main_id]]))
                foreach($index[$row[$attributeDefn->main_id]] as $r)
                  $this->mergeColumnData($data[$r][$column], $row['int_value']);
              break;
            case 'B':
              if(isset($index[$row[$attributeDefn->main_id]]))
                foreach($index[$row[$attributeDefn->main_id]] as $r)
                  $this->mergeColumnData($data[$r][$column], $row['int_value'] ? 'Yes' : 'No');
              break;
            case 'F':
              if(isset($index[$row[$attributeDefn->main_id]]))
                foreach($index[$row[$attributeDefn->main_id]] as $r)
                  $this->mergeColumnData($data[$r][$column], $row['float_value']);
              break;
            case 'T':
              if(isset($index[$row[$attributeDefn->main_id]]))
                foreach($index[$row[$attributeDefn->main_id]] as $r)
                  $this->mergeColumnData($data[$r][$column], $row['text_value']);
              break;
            case 'D':
            case 'V': // assume no multi values: would be far too complex to deal with...
              if(isset($index[$row[$attributeDefn->main_id]]))
                foreach($index[$row[$attributeDefn->main_id]] as $r){
                  $data[$r][$column."_date_start"] = $row['date_start_value'];
                  $data[$r][$column."_date_end"] = $row['date_end_value'];
                  $data[$r][$column."_date_type"] = $row['date_type_value'];
                }
              break;
          }
        }
        for ($r=0; $r<$dataCount; $r++) {
          foreach($newColumns as $newCol){
            $column = $newCol['column'];
            if($newCol['multi_value'] == true && is_array($data[$r][$column])){
              $data[$r][$column] = implode($attributeDefn->separator, $data[$r][$column]);
            }
          }
        }
    }
  }

  private function mergeColumnData(&$data, $value){
    if(is_array($data)){
      $data[] = $value;
    } else {
      $data = $value;
    }
  }

  /* The following function is the only method by which the reports can update the contents of the database. As a consequence
   * the following restrictions are enforced:
   * 1) the updates are not data driven. The only thing updated is the downloaded column in the occurrences table, and this
   *    is hardcoded.
   *
   */
  private function setDownloaded($data, $downloadDetails)
  {
    if($downloadDetails->mode == 'INITIAL' || $downloadDetails->mode == 'FINAL') {
      $idList = array();
      foreach($data as $row){
        if(isset($row[$downloadDetails->id])){
          $idList[] = $row[$downloadDetails->id];
          if(count($idList) >= self::rowsPerUpdate){
            $this->updateDownloaded($idList, $downloadDetails->mode);
            $idList = array();
          }
        }
      }
      $this->updateDownloaded($idList, $downloadDetails->mode);
    }
  }

  private function updateDownloaded($idList, $mode)
  {
    if(!is_array($idList) || count($idList) == 0)
      return;
    if($mode != 'INITIAL' && $mode != 'FINAL') {
      return;
    }
    $downloaded_on = date("Ymd H:i:s");
    $db = new Database(); // use default access so can update.
    $db->query('START TRANSACTION READ WRITE;');
    $response = $db->in("id", $idList)->where("downloaded_flag", ($mode == 'FINAL'? 'I' : 'N'))
        ->update('occurrences',
          array('downloaded_flag' => ($mode == 'FINAL'? 'F' : 'I'),
              'downloaded_on' => $downloaded_on,
              'updated_on' => $downloaded_on));
    $response = $db->in("id", $idList)->where("downloaded_flag", ($mode == 'FINAL'? 'I' : 'N'))
        ->update('cache_occurrences',
          array('downloaded_flag' => ($mode == 'FINAL'? 'F' : 'I')));
    $db->query('COMMIT;');
  }

  private function fetchLocalReport($request)
  {
    $this->report = null;
    if (is_file($this->localReportDir.'/'.$request)) {
      $this->report = $this->localReportDir.'/'.$request;
      Kohana::log('debug', "Setting local report ".$this->report.".");
    } else {
      foreach (Kohana::config('config.modules') as $path) {
        if (is_file("$path/reports/$request")) {
          $this->report = "$path/reports/$request";
          break;
        }
      }
    }
    if ($this->report===null)
      throw new exception("Unable to find report $request.");
  }

  private function fetchRemoteReport($request)
  {
    $this->report = $request;
  }

  private function fetchProvidedReport($request)
  {
    // $request here stores the report itself - we save it to a temporary place.
    $uploadDir = $this->localReportDir.'/tmp/';
    if (is_dir($uploadDir))
    {
      $fname = time();
      switch ($this->reportFormat)
      {
  case 'xml':
    $fname .= '.xml';
    break;
  default:
    // Bad stuff
    // TODO
      }
      if (file_put_contents($uploadDir.$fname, $request))
        $this->report = $uploadDir.$fname;
      else {
  // Error - unable to write to temp dir.
  // TODO
      }
    }
    else
    {
      // Unable to cache the report - could try other things, but nah.
    }
  }

  private function mergeQuery()
  {
    // Grab the query from the report reader
    $query = $this->reportReader->getQuery();
    $this->query = $this->mergeQueryWithParams($query);
    $this->reportReader->applyPrivilegesFilters($this->query, $this->websiteIds, $this->providedParams['training'], $this->sharingMode, $this->userId);
  }

  private function mergeCountQuery()
  {
    // Grab the query from the report reader
    $query = $this->reportReader->getCountQuery();
    if ($query!==null) {
      $this->countQuery = $this->mergeQueryWithParams($query, true);
      $this->reportReader->applyPrivilegesFilters($this->countQuery, $this->websiteIds, $this->providedParams['training'], $this->sharingMode, $this->userId);
    } else
      $this->countQuery = null;
  }

  private function mergeQueryWithParams($query, $counting=false)
  {
    // Replace each parameter in place
    $paramDefs = $this->reportReader->getParams();
    // Clear the list of standardised parameter joins so we start afresh
    $this->doneStandardParamJoins = array();
    // Pre-parse joins defined by parameters, so that join SQL also gets other parameter values
    // inserted
    foreach ($this->providedParams as $name => $value)
    {
      if (isset($paramDefs[$name])) {
        if (array_key_exists('joins', $paramDefs[$name]))
          $query = $this->addParamJoins($query, $paramDefs[$name], $value);
        if (array_key_exists('wheres', $paramDefs[$name]))
          $query = $this->addParamWheres($query, $name, $paramDefs[$name], $value);
      }
    }
    // Now loop through the joins to insert the values into the query
    foreach ($this->providedParams as $name => $value)
    {
      if (isset($paramDefs[$name])) {
        if ($value==='') {
          $empty = isset($paramDefs[$name]['emptyvalue']) ? $paramDefs[$name]['emptyvalue'] : '';
          // empty integer params should be handled as 0 (null would be ideal, but we can't test for it in the same fashion as a number).
          $query = preg_replace("/#$name#/", $empty, $query);
        }
        else {
          if ($paramDefs[$name]['datatype']=='idlist')
            // idlist is a special parameter type which creates an IN (...) clause. Lets you optionally provide a list
            // of ids for a report.
            $query = preg_replace("/#$name#/", "AND ".$paramDefs[$name]['fieldname']." IN ($value)", $query);
          elseif ($paramDefs[$name]['datatype']=='excludeidlist')
            $query = preg_replace("/#$name#/", "AND ".$paramDefs[$name]['fieldname']." NOT IN ($value)", $query);
          elseif ($paramDefs[$name]['datatype']=='smpattrs')
            $query = $this->mergeAttrListParam($query, 'sample', $value);
          elseif ($paramDefs[$name]['datatype']=='smp2attrs')
            $query = $this->mergeAttrListParam($query, 'sample', $value, "2");
          elseif ($paramDefs[$name]['datatype']=='occattrs')
            $query = $this->mergeAttrListParam($query, 'occurrence', $value);
          elseif ($paramDefs[$name]['datatype']=='occ2attrs')
            $query = $this->mergeAttrListParam($query, 'occurrence', $value, "2");
          elseif ($paramDefs[$name]['datatype']=='locattrs')
            $query = $this->mergeAttrListParam($query, 'location', $value);
          elseif ($paramDefs[$name]['datatype']=='loc2attrs')
            $query = $this->mergeAttrListParam($query, 'location', $value, "2");
          elseif ($paramDefs[$name]['datatype']=='taxattrs')
            $query = $this->mergeAttrListParam($query, 'taxa_taxon_list', $value);
          elseif ($paramDefs[$name]['datatype']=='trmattrs')
            $query = $this->mergeAttrListParam($query, 'termlists_term', $value);
          elseif ($paramDefs[$name]['datatype']=='srvattrs')
            $query = $this->mergeAttrListParam($query, 'survey', $value);
          elseif ($paramDefs[$name]['datatype']=='psnattrs')
            $query = $this->mergeAttrListParam($query, 'person', $value);
          else {
            // sanitise
            if ($paramDefs[$name]['datatype']==='text' || $paramDefs[$name]['datatype']==='string') {
              // ensure value is escaped for apostrophes
              $value = pg_escape_string($value);
            }
            elseif ($paramDefs[$name]['datatype']==='text[]' || $paramDefs[$name]['datatype']==='string[]') {
              // array check on text parameter values
              if (strlen($value)) {
                $arr = str_getcsv($value, ",", "'");
                foreach ($arr as &$item)
                  $item = pg_escape_string($item);
                $value = "'" . implode("','", $arr) . "'";
              }
            }
            elseif (($paramDefs[$name]['datatype']==='integer' || $paramDefs[$name]['datatype']==='float') && !is_numeric($value))
              throw new exception('Invalid numeric parameter value');
            elseif (($paramDefs[$name]['datatype']==='integer[]' || $paramDefs[$name]['datatype']==='float[]')) {
              // array check on numeric parameter values
              $arr = explode(',', $value);
              foreach ($arr as $item) {
                if (!is_numeric($item))
                  throw new exception("Invalid numeric array parameter value $value");
              }
            }
            elseif ($paramDefs[$name]['datatype']==='date' && preg_match('/\d{4}$/', $value)) {
              // force ISO date for SQL safety.
              // @todo This needs further work for i18n if non-European.
              $date = DateTime::createFromFormat('d/m/Y', $value);
              if (!$date)
                throw new exception("Invalid date parameter value $value");
              $value = $date->format('Y-m-d');
            }
            if (!empty($paramDefs[$name]['preprocess']) && !empty($value) && $value!=="null") {
              // use a preprocessing query to calculate the actual param value to use
              $prequery = str_replace("#$name#", $value, $paramDefs[$name]['preprocess']);
              $output = $this->reportDb->query($prequery)->result_array(FALSE);
              $value = implode(',', $output[0]);
            }
            $query = preg_replace("/#$name#/", $value, $query);
          }
        }
      }
      elseif (isset($this->customAttributes[$name])) {
        // request includes a custom attribute column being used as a filter.
        if ($this->customAttributes[$name]['string'])
          $value =  "'" . pg_escape_string($value) . "'";
        $filter=str_replace('#filtervalue#', $value, $this->customAttributes[$name]['filter']);
        $query = str_replace('#filters#', "AND $filter\n#filters#", $query);
      }
      elseif (isset($this->reportReader->filterableColumns[$name])) {
        $field = $this->reportReader->filterableColumns[$name]['sql'];
        $filterClause = $this->getFilterClause($field, $this->reportReader->filterableColumns[$name]['datatype'], $operator, $value);
        if (isset($this->reportReader->columns[$name]['aggregate'])
            && $this->reportReader->columns[$name]['aggregate']==='true')
          $this->having[] = $filterClause;
        else
          $query = str_replace('#filters#', "AND $filterClause\n#filters#", $query);
      }
      elseif (preg_match('/(?P<prefix>.*)date$/', $name, $matches)
          && array_key_exists($matches['prefix'].'date_start', $this->reportReader->columns)
          && array_key_exists($matches['prefix'].'date_end', $this->reportReader->columns)
          && array_key_exists($matches['prefix'].'date_type', $this->reportReader->columns)) {
        // special handling for a filter on a vague date added column
        $field = $this->reportReader->columns[$matches['prefix'].'date_start']['sql'];
        $filterClause = $this->getFilterClause($field, 'date', $operator, $value);
        $query = str_replace('#filters#', "AND $filterClause\n#filters#", $query);
      }
    }
    // column replacements and additional join to samples for geometry permissions autoswitching
    if ($this->sharingMode==='me' || $this->sharingMode==='verification' || $this->groupAllowsSensitiveAccess()) {
      // don't add the join to samples when it is not necessary.
      if (strpos($query, '#sample_sref_field#') || strpos($query, '#sample_geom_field#'))
        $query = str_replace('#joins#', "JOIN samples s on s.id=o.sample_id AND s.deleted=false \n#joins#", $query);
      $query = str_replace(array('#sample_sref_field#', '#sample_geom_field#'), array('s.entered_sref', 's.geom'), $query);
    } else {
      if ($this->reportReader->loadLegacyStandardParamsSet)
        $query = str_replace(array('#sample_sref_field#', '#sample_geom_field#'), array('o.public_entered_sref', 'o.public_geom'), $query);
      else
        $query = str_replace(array('#sample_sref_field#', '#sample_geom_field#'), array('snf.public_entered_sref', 'o.public_geom'), $query);
    }
    $having = empty($this->having) ? '' : "\nHAVING " . implode(' AND ', $this->having);
    // remove the markers left in the query to show where to insert joins, filters etc. This also sets up the query
    // HAVING clause where relevant.
    $query = str_replace(
      array('#joins#','#fields#','#group_bys#','#having#','#filters#','#idlist#'),
      array('','','',$having,'',''),
    $query);
    // allow the URL to provide a sort order override
    if (!$counting) {
      // prioritise any URL provided sort order, but still keep any other sort ordering in the report.
      $orderBy=$this->reportReader->getOrderClause();
      if($orderBy){
        if (isset($this->orderby))
          $orderBy = $this->orderby . (isset($this->sortdir) ? ' '.$this->sortdir : '') . ', ' . $orderBy;
      } else if (isset($this->orderby))
          $orderBy = $this->orderby . (isset($this->sortdir) ? ' '.$this->sortdir : '');
      if ($orderBy) {
        $orderBy = $this->checkOrderByForVagueDate($orderBy);
        if (strpos($query, 'distinct on')===FALSE) {
          $orderBy = $this->optimiseQueryPlan($orderBy);
        }
        // Order by will either be appended to the end of the query, or inserted at a #order_by# marker.
        $count=0;
        $query = preg_replace("/#order_by#/",  "ORDER BY $orderBy", $query, -1, $count);
        if ($count==0) {
          $query .= " ORDER BY $orderBy";
        }
      } else {
        $query = preg_replace("/#order_by#/",  "", $query);
      }
      if (isset($this->limit))
        $query .= ' LIMIT '.$this->limit;
      if ($this->offset)
        $query .= ' OFFSET '.$this->offset;
    } else {
      $query = preg_replace("/#order_by#/",  "", $query);
    }
    return $query;
  }

  /**
   * Forces a switch of query plan to avoid slow queries where the record count is less than the limit, causing a
   * walk through the entire table.
   * @param string $orderBy Current query order by setting
   * @return string
   * @link http://stackoverflow.com/questions/6037843/extremely-slow-postgresql-query-with-order-and-limit-clauses
   */
  private function optimiseQueryPlan($orderBy) {
    if (preg_match('/o.id (desc|asc)/i', $orderBy)
        && ((isset($_REQUEST['wantCount']) && $_REQUEST['wantCount']==='1') || isset($_REQUEST['knownCount']))) {
      // grab the count now. If less than the limit, we fudge the order by to switch query plan.
      $count = isset($_REQUEST['knownCount']) ? $_REQUEST['knownCount'] : $this->record_count();
      if ($count !== false && $count < $this->limit) {
        kohana::log('debug', 'Optimising query plan by changing sort order to o.id+0.');
        return str_replace('.id', '.id+0', $orderBy);
      }
    }
    return $orderBy;
  }

  /**
   * Returns true if the report is using standard parameters and is limited to a group ID which allows its members to view
   * sensitive records, only if the current user is a group member.
   */
  private function groupAllowsSensitiveAccess() {
    // basic checks we can perform to avoid unnecessary db access
    if (!$this->reportReader->loadStandardParamsSet || !$this->userId ||
        (empty($this->providedParams['group_id']) && empty($this->providedParams['implicit_group_id'])))
      return false;
    $group_id = empty($this->providedParams['group_id']) ? $this->providedParams['implicit_group_id'] : $this->providedParams['group_id'];
    // use the cache to avoid db access
    $key = "allowSensitiveAccessForGroup-$group_id-$this->userId";
    $cache = new Cache();
    $value = $cache->get($key);
    if ($value===null) {
      // this checks both that the group allows full precision viewing, plus that the user is a group member.
      $value = $this->reportDb->select('groups.id')
          ->from('groups')
          ->join('groups_users', 'groups_users.group_id', 'groups.id')
          ->where(array('group_id' => $group_id, 'view_full_precision'=>'t', 'groups_users.user_id'=>$this->userId))
          ->get()->count() > 0;
      $cache->set($key, $value);
    }
    return $value;
  }

  /**
   * Retrieve the filter required by a column filter row search
   */
  private function getFilterClause($field, $datatype, &$operator, &$value) {
    if ($datatype=='text' || $datatype==='species') {
      if ($datatype==='species') {
        // skip subgenera from species searches
        $value = preg_replace('/\(.*?\) /', '', $value);
        $field = "regexp_replace($field, '(\(.*\)|\s)', '', 'g')";
      }
      // quote text values and replace * wildcards with SQL friendly ones.
      $value=str_replace('*','%',$value);
      //by default add a wildcard to the end
      if (substr($value, -1)!=='%')
        $value .= '%';
      $operator='ILIKE';
    } else
      $operator = '=';

    if ($datatype!=='text' && $datatype!=='date') {
      //strip spaces so the user can be more flexible about spaces they enter
      //Note: Don't use this for text filter as spacing might be important for the search.
      //For dates, spacing will be handled by the vague date engine
      $value = str_replace(" ","",$value);
      //apart from text and date values we handle the case where the user enters a range e.g. 1-3
      // @todo: is there an i18n consideration here with the .?
      if (preg_match('/(?P<from>\d+(\.\d+)?)(-|to)(?<to>\d+(\.\d+)?)/', $value, $matches))
        return "$field BETWEEN ".$matches['from']." AND ".$matches['to'];
      // support <, <=, >, >= operators
      if (preg_match('/(?P<op>(>|<|>=|<=))(?P<val>\d+(\.\d+)?)/', $value, $matches))
        return "$field ".$matches['op']." ".$matches['val'];
    }
    if ($datatype==='text' || $datatype==='species') {
      // ensure value is escaped for apostrophes
      $value = pg_escape_string($value);
      // quote text and date values
      $value="'".$value."'";
    }
    if ($datatype != 'date') {
      return "$field $operator $value";}
    else {
      $vaguedate = vague_date::string_to_vague_date($value);
      return "($field >= '".$vaguedate[0]."' AND $field <= '".$vaguedate[1]."')";
    }
  }

  /**
   * When a parameter is found which defines a list of additional custom attributes to add to a report,
   * this method merges the parameter information into the query, adding in joins and fields to return the
   * selected attributes.
   * @param string $query SQL query to process
   * @param string $entity Either occurrence, location or sample depending on the type of attributes being loaded.
   * @param string $attrList parameter value, which should be a comma separated list of attribute IDs or attribute names.
   * @param string an optional index number when dealing with parent/child table arrangements
   * @return string Processed query.
   */
  private function mergeAttrListParam($query, $entity, $attrList, $idx = "") {
    $this->reportDb
        ->select('distinct a.id, a.data_type, a.caption, a.validation_rules, a.system_function, a.multi_value')
        ->from("{$entity}_attributes as a");
    if ($this->websiteIds) {
      $websiteIds = implode(',', $this->websiteIds);
      // A 'me' share is basically a subtype of a reporting share mode.
      $sharingMode = $this->sharingMode === 'me' ? 'reporting' : $this->sharingMode;
      $this->reportDb
          ->join("{$entity}_attributes_websites as aw", "aw.{$entity}_attribute_id", 'a.id')
          ->join('index_websites_website_agreements as wa', 'wa.from_website_id', 'aw.website_id', 'LEFT')
          ->where("(wa.to_website_id in ($websiteIds) or wa.to_website_id is null)")
          ->where(array('aw.deleted' => 'f'))
          ->where("(wa.provide_for_$sharingMode='t' or wa.provide_for_$sharingMode is null)");
    }
    $ids = array();
    $captions = array();
    $sysfuncs = array();
    $attrList = explode(',',$attrList);
    $allSurveyAttrs=false;
    // Find an attribute that supports survey filtering as this allows us to retrieve the specific set of attributes for the survey
    if (!empty($this->providedParams['survey_list']))
      $surveys = $this->providedParams['survey_list'];
    elseif (!empty($this->providedParams['surveys']))
      $surveys = $this->providedParams['surveys'];
    elseif (!empty($this->providedParams['survey_id']))
      $surveys = $this->providedParams['survey_id'];
    else
      $surveys=false;
    foreach($attrList as $attr) {
      if (is_numeric($attr))
        $ids[] = $attr;                 // an attribute ID
      elseif ($attr==='#all_survey_attrs' && $surveys)
        $allSurveyAttrs=true;           // requesting all attributes for a single selected survey
      elseif (substr($attr, 0, 1)==='#')
        $sysfuncs[] = substr($attr, 1); // a system function
      else
        $captions[] = $attr;            // an attribute caption
    }
    unset($attrList['#all_survey_attrs']);
    // a request for all attrs in a selected survey?
    if ($surveys) {
      if (isset($websiteIds)) {
        $this->reportDb->where("(aw.restrict_to_survey_id in ($surveys) " .
          "or (aw.restrict_to_survey_id is null and aw.website_id in ($websiteIds)))");
      } else {
        // may have come from warehouse frontend where no website provided, but a survey has been
        // need aw table.
        $this->reportDb
            ->join("{$entity}_attributes_websites as aw", "aw.{$entity}_attribute_id", 'a.id')
            ->where(array('aw.deleted' => 'f'));
        $this->reportDb->where("aw.restrict_to_survey_id in ($surveys)");
      }
    }
    if ($allSurveyAttrs) {
      // don't auto include email & cms_user_id to keep it private
      $this->reportDb->notin('system_function', array('email','cms_user_id'));
    } else {
      if ((count($ids)===0 ? 0 : 1) + (count($captions)===0 ? 0 : 1) + (count($sysfuncs)===0 ? 0 : 1) > 1)
        throw new exception('Cannot mix numeric IDs, captions and system functions in the list of requested custom attributes');
      if (count($ids)>0)
        $this->reportDb->in('a.id', $ids);
      elseif (count($captions)>0)
        $this->reportDb->in('caption', $captions);
      elseif (count($sysfuncs)>0)
        $this->reportDb->in('system_function', $sysfuncs);
    }
    $attrs = $this->reportDb->get();
    // we want the attributes to appear in the order they have been provided in the list. Can't do through SQL.
    if (!$allSurveyAttrs) { // don't sort if getting all: Note that there isn't a sample_method or location_type style restriction on the attributes fetched.
      $newAttrList = array();
      foreach($attrList as $attrID)
        foreach($attrs as $attr)
          if ((count($ids)>0 && $attr->id == $attrID) ||
              (count($captions)>0 && $attr->caption == $attrID) ||
              (count($sysfuncs)>0 && $attr->system_function == preg_replace('/^#/', '', $attrID)))
            $newAttrList[] = $attr;
      $attrs = $newAttrList;
    }
    if (!$allSurveyAttrs && count($sysfuncs)>0)
      $this->processSysfuncAttrs($query, $entity, $attrs, $idx);
    else {
      $usingCaptions=count($captions)>0;
      $this->processStandardAttrs($query, $entity, $attrs, $usingCaptions, $idx);
    }
    return $query;
  }

  /**
   * Returns the field name that needs to be picked out of the attribute values or terms table
   * for a particular data type.
   * @param string $entity E.g. occurrence or sample
   * @param string $sysfunc Name of the system function, required to build the correct field alias.
   * @param string $dataType Character identifying the field's type, e.g. L for lookup.
   * @param boolean $forceVarchar Set true if there are mixed datatypes, so non-text will be forced to varchar.
   * @return string
   */
  private function getSysFuncFieldName($entity, $sysfunc, $dataType, $forceVarchar) {
    $suffix = $forceVarchar ? '::varchar' : '';
    switch ($dataType) {
      case 'F':
        return "{$entity}_$sysfunc.float_value$suffix\n";
        break;
      case 'I':
        return "{$entity}_$sysfunc.int_value$suffix\n";
        break;
      case 'T':
        return "{$entity}_$sysfunc.text_value\n";
        break;
      case 'D':
      case 'V':
      return "{$entity}_$sysfunc.date_start_value$suffix\n";
        break;
      case 'L':
        return "t{$entity}_$sysfunc.term\n";
        break;
      default:
        return "{$entity}_$sysfunc.text_value\n";
    }
  }

  /**
   * Create the joins and column definitions required to support a set of custom attributes
   * added to the report by specifying one or more system functions.
   * @param string $query Query string being built, will be modified to add joins and fields.
   * @param string $entity E.g. occurrence or sample
   * @param array $attrs List of attribute definitions loaded.
   */
  private function processSysfuncAttrs(&$query, $entity, $attrs, $idx) {
    $sysfuncsList = array();
    // For occurrences or samples reports loaded from the cache tables, we've got the sysfunc columns all ready in the cache.
    // Otherwise we need to join the attribute values in.
    if ($this->reportReader->loadStandardParamsSet==='occurrences' || $this->reportReader->loadStandardParamsSet==='samples') {
      foreach ($attrs as $attr) {
        if (!empty($attr->system_function) && !in_array($attr->system_function, $sysfuncsList)) {
          $query = str_replace('#fields#', ", \nattr_$attr->system_function#fields#", $query);
          $query = str_replace('#group_bys#', ", attr_$attr->system_function#group_bys#", $query);
          $sysfuncsList[] = $attr->system_function;
        }
      }
    } else {
      // We can't use the cache occurrences or samples table columns
      // First, join in all the attribute tables we need
      $done = array();
      $sysfuncsList = array();
      // find all the system functions in the list of attributes we've been given. Prepare some
      // metadata required for each sys func's set of joints
      foreach ($attrs as $attr) {
        if (!empty($attr->system_function)) {
          // Don't duplicate any attributes as the SQL distinct does not force distinct when loading from a view.
          // Plus, ignore multi-value attributes as too complex to combine with single value attributes.
          if (in_array($attr->id, $done) || $attr->multi_value === 't') {
            continue;
          }
          $id = $attr->id;
          $done[] = $id;
          if (!isset($sysfuncsList[$attr->system_function])) {
            $sysfuncsList[$attr->system_function] = array(
              'ids' => array(),
              'hasTerm' => FALSE,
              'idsByDatatype' => array()
            );
          }
          // store the ids associated with each sysfunc so we can build the joins
          $sysfuncsList[$attr->system_function]['ids'][] = $attr->id;
          // If a lookup attribute, then the join for this system function will need to join cache_termlists_terms
          if ($attr->data_type === 'L') {
            $sysfuncsList[$attr->system_function]['hasTerm'] = TRUE;
          }
          // store the ids associated with each type of data for each sysfunc so we can efficiently build SQL to output the value
          if (!isset($sysfuncsList[$attr->system_function]['idsByDatatype'][$attr->data_type])) {
            $sysfuncsList[$attr->system_function]['idsByDatatype'][$attr->data_type] = array();
          }
          $sysfuncsList[$attr->system_function]['idsByDatatype'][$attr->data_type][] = $attr->id;
        }
      }
      foreach ($sysfuncsList as $sysfunc => $metadata) {
        $alias = "attr_$sysfunc";
        $fieldSql = "CASE \n";
        foreach ($metadata['idsByDatatype'] as $data_type => $ids) {
          $ids = implode(',', $ids);
          $fieldSql .= "  WHEN {$entity}_$sysfunc.{$entity}_attribute_id IN ($ids) THEN " .
            $this->getSysFuncFieldName($entity, $sysfunc, $data_type, count($metadata['idsByDatatype']) > 1);
        }
        $fieldSql .= "END";
        $query = str_replace('#fields#', ", \n$fieldSql AS $alias#fields#", $query);
        $query = str_replace('#group_bys#', ", $fieldSql#group_bys#", $query);
        $joinFieldAttr = inflector::plural($entity) . '_id_field';
        $joinToField = $this->reportReader->$joinFieldAttr;
        $ids = implode(',', $metadata['ids']);
        $join = "LEFT JOIN {$entity}_attribute_values {$entity}_$sysfunc ON {$entity}_$sysfunc.{$entity}_id=$joinToField AND {$entity}_$sysfunc.deleted=false " .
          "AND {$entity}_$sysfunc.{$entity}_attribute_id IN ($ids)";
        $query = str_replace('#joins#', "$join\n#joins#", $query);
        if ($metadata['hasTerm']) {
          $join = 'LEFT JOIN ' . (class_exists('cache_builder') ? "cache_termlists_terms" : "list_termlists_terms") .
            " t{$entity}_$sysfunc ON t{$entity}_$sysfunc.id = {$entity}_$sysfunc.int_value";
          $query = str_replace('#joins#', "$join\n#joins#", $query);
        }
      }
    }
  }

  /**
   * Retrieve the columns involved in storing the data for a given attribute, depending on its data type.
   *
   * @return array Array keyed by list of column names, with qualifying suffix so add to column caption if there are
   * multiple.
   */
  private function getAttrDataColumns($attr) {
    switch($attr->data_type) {
      case 'F' :
        $cols = array('float_value'=>'');
        break;
      case 'T' :
        $cols = array('text_value'=>'');
        break;
      case 'D' :
        $cols = array('date_start_value'=>'');
        break;
      case 'V' :
        $cols = array('date_start_value'=>' start','date_end_value'=>' end','date_type_value'=>' type');
        break;
      case 'L' :
        $cols= array('int_value'=>'');
        // lookups will have the join inserted later
        break;
      default:
        $cols = array('int_value'=>'');
    }
    return $cols;
  }

  /**
   * Create the joins and column definitions required to support a set of custom attributes
   * added to the report by specifying one or more attributes by ID or caption.
   */
  private function processStandardAttrs(&$query, $entity, $attrs, $usingCaptions, $idx) {
    $done = array();
    $idx_ = $idx == '' ? '' : $idx.'_';
    foreach($attrs as $attr) {
      // don't duplicate any attributes as the SQL distinct does not force distinct when loading from a view.
      if (in_array($attr->id, $done))
        continue;
      $id = $attr->id;
      $done[]=$id;
      $joinType = $this->addJoinForAttr($query, $entity, $attr, false, $idx);
      // find the query column(s) required for the attribute
      $cols = $this->getAttrDataColumns($attr);
      // We use the attribute ID or the attribute caption to create the unique column alias, depending on how it was requested.
      $uniqueId = $usingCaptions ? preg_replace('/\W/', '_', strtolower($attr->caption)) : $id;
      $alias = "attr_id_{$entity}{$idx}_$uniqueId";
      // Find out what query field alias we need to join the attribute to (e.g. s.id for samples, l.id for locations).
      $joinFieldAttr = inflector::plural($entity).$idx.'_id_field';
      $joinToField = $this->reportReader->$joinFieldAttr;
      // Create the fields required in the SQL. First the attribute value ID(s).
      if ($attr->multi_value==='t')
        $query = str_replace('#fields#', ", (select array_to_string(array_agg(mv$alias.id), ', ')
  from {$entity}_attribute_values mv$alias
  where mv$alias.{$entity}_id=$joinToField and mv$alias.{$entity}_attribute_id=$id AND deleted = FALSE) as $alias#fields#", $query);
      else {
        $query = str_replace('#fields#', ", $entity${idx_}$id.id as $alias#fields#", $query);
        // this field should also be inserted into any group by part of the query
        $query = str_replace('#group_bys#', ", $entity${idx_}$id.id#group_bys#", $query);
      }
      // hide the value ID column
      $this->attrColumns[$alias] = array(
        'visible' => 'false'
      );
      $doneFilter = false;
      // Now add the attribute data col(s) to the SQL fields
      foreach($cols as $col=>$suffix) {
        $alias = "attr_{$entity}{$idx}_$uniqueId";
        // vague date cols need to distinguish the different column types.
        if ($attr->data_type=='V')
          $alias .= $col;
        elseif ($attr->data_type=='L') {
          // main output column for lookups is an ID column, so clarify the caption to reflect this
          $suffix .= ' term ID';
        }
        // Work out the field to insert into the query, and potentially the group by if required
        if ($attr->multi_value==='t') {
          // multivalue so use a subquery to build a CSV list of the data, no need to group by as this is aggregated
          $field="(select array_to_string(array_agg(mv$alias.$col), ', ')
  from {$entity}_attribute_values mv$alias
  where mv$alias.{$entity}_id=$joinToField and mv$alias.{$entity}_attribute_id=$id AND deleted = FALSE)";
        } else {
          $field = "$entity${idx_}$id.$col";
          $query = str_replace('#group_bys#', ", $entity${idx_}$id.$col#group_bys#", $query);
        }
        $query = str_replace('#fields#', ", $field as $alias#fields#", $query);

        // For each attribute, use the first column to prepare the SQL required should this column be used in a filter later.
        if (!$doneFilter) {
          $doneFilter = true;
          // identify strings, so we can escape values properly
          $filterIsString = preg_match('/[TDV]/', $attr->data_type) || $attr->multi_value==='t';
          if ($attr->multi_value==='t')
            $filter = "exists(select mv$alias.$col
  from {$entity}_attribute_values mv$alias
  where mv$alias.{$entity}_id=$joinToField and mv$alias.{$entity}_attribute_id=$id and mv$alias.$col=#filtervalue# AND mv$alias.deleted = FALSE )";
          else
            $filter = "$field=#filtervalue#";
          // store the filter for later
          $this->customAttributes["attr_$entity{$idx}_$uniqueId"] = array(
            'filter' => $filter,
            'string' =>  $filterIsString
          );
        }
        $this->attrColumns[$alias] = array('display' => $attr->caption.$suffix);
      }
      // add a column to set the caption for vague date processed columns
      if ($attr->data_type=='V') {
        $this->attrColumns["attr_$entity${idx}_$uniqueId".'date'] = array(
          'display' => $attr->caption
        );
      }
      // lookups need special processing for additional joins to include the term data
      elseif ($attr->data_type=='L') {
        $alias = preg_replace('/\_value$/', '', "attr_$entity${idx}_term_$uniqueId");
        if ($attr->multi_value==='f') {
          $query = str_replace('#joins#', $joinType." ".(class_exists('cache_builder') ? "cache_termlists_terms" : "list_termlists_terms")." ltt{$idx_}{$id} ON ltt{$idx_}$id.id={$entity}{$idx_}$id.int_value\n #joins#", $query);
          $query = str_replace('#fields#', ", ltt{$idx_}{$id}.term as $alias#fields#", $query);
          $query = str_replace('#group_bys#', ", ltt{$idx_}{$id}.term#group_bys#", $query);
          $this->customAttributes["attr_$entity${idx}_term_$uniqueId"] = array(
            'filter' => "$field=#filtervalue#",
            'string' => true
          );
        } else {
          // multi-value, so use an aggregate to build a CSV list of the terms
          $field="(select array_to_string(array_agg(term{$alias}.term), ', ')
  from {$entity}_attribute_values mv$alias
  join ".(class_exists('cache_builder') ? "cache_termlists_terms" : "list_termlists_terms")." term{$alias} on term{$alias}.id=mv$alias.int_value
  where mv$alias.{$entity}_id=$joinToField and mv$alias.{$entity}_attribute_id=$id AND mv$alias.deleted = FALSE)";
          $query = str_replace('#fields#', ", $field as $alias#fields#", $query);
          // also use an exists subquery to check the multivalue term in the case of filtering against this column
          $this->customAttributes["attr_$entity${idx}_term_$uniqueId"] = array(
            'filter' => "exists(select term{$alias}.term
  from {$entity}_attribute_values mv$alias
  join ".(class_exists('cache_builder') ? "cache_termlists_terms" : "list_termlists_terms")." term{$alias} on term{$alias}.id=mv$alias.int_value
  where mv$alias.{$entity}_id=$joinToField and mv$alias.{$entity}_attribute_id=$id and term{$alias}.term=#filtervalue#)",
            'string' => true
          );
        }
        $this->attrColumns["attr_$entity${idx}_term_$uniqueId"] = array(
          'display' => $attr->caption.' term'
        );
      }
      // if we know an attribute caption, we want to be able to lookup the ID.
      $this->customAttributeCaptions["$entity$idx:".$attr->caption] = $id;
    }
  }

  /**
   * Adds the join required for a custom attribute to the query.
   *
   * @return string Either LEFT JOIN (optional attributes) or JOIN (required attributes) so that further related joins can be constructed.
   */
  private function addJoinForAttr(&$query, $entity, $attr, $forceOuter, $idx) {
    // can only use an inner join for definitely required fields. If they are required
    // only at the per-survey level, we must use left joins as the survey could vary per record.
    $idx_ = $idx == '' ? '' : $idx.'_';
    $joinType = (strpos($attr->validation_rules, 'required')===false || $forceOuter) ? 'LEFT JOIN' : 'JOIN';
    // We only need to add a join to the report for single value attributes, as multi-value attributes use a subquery to retrieve the field value
    if ($attr->multi_value==='f') {
      $id = $attr->id;
      // find out what alias and field name the query uses for the table & field we need to join to
      // (samples.id, occurrences.id or locations.id).
      $joinFieldAttr = inflector::plural($entity).$idx.'_id_field';
      $joinToField = $this->reportReader->$joinFieldAttr;
      // construct a join to the attribute values table so we can get the value out.
      $join = "$joinType {$entity}_attribute_values $entity{$idx_}$id ON $entity{$idx_}$id.{$entity}_id=$joinToField AND $entity{$idx_}$id.{$entity}_attribute_id=$id AND $entity{$idx_}$id.deleted=false";
      $query = str_replace('#joins#', "$join\n #joins#", $query);
    }
    return $joinType;
  }

  /**
   * When filtering against a location type that is indexed by the spatial index builder, if the
   * location type has a unique index there will be a location_id_* column pointing to the id
   * in cache_occurrences_functional. This switches from the standard join method to a direct
   * filter on this field as its much faster.
   * @param $id
   * @return null
   */
  private function locationIdUniquelyIndexedType($id) {
    if (preg_match('/^\d+$/', $id)) {
      $config=kohana::config_load('spatial_index_builder', false);
      if (array_key_exists('unique', $config)) {
        $r = $this->reportDb->select('cache_termlists_terms.term')
          ->from('locations l')
          ->join('cache_termlists_terms', array('cache_termlists_terms.id' => 'l.location_type_id'))
          ->where('l.id', $id)
          ->in('cache_termlists_terms.term', $config['unique'])
          ->get();
        if ($r->count()>0) {
          return $r->current()->term;
        }
      }
    }
    return null;
  }

  /**
   * Add any joins defined by a used parameter to the query.
   */
  private function addParamJoins($query, $paramDef, $value) {
    if ($value && isset($paramDef['custom']) && $paramDef['custom']==='unique_location_index') {
      // special case for this parameter when the location is a unique indexed location type,
      // since we can use a more effective where clause instead of the join.
      if ($this->locationIdUniquelyIndexedType($value))
        return $query;
    }
    $joins = array();
    foreach($paramDef['joins'] as $joinDef) {
      if ((!empty($joinDef['operator']) && (($joinDef['operator']==='equal' && $joinDef['value']===$value) ||
          ($joinDef['operator']==='notequal' && $joinDef['value']!==$value)))
          // operator not provided, so default is to join if param not empty (null string passed for empty integers)
          || (empty($joinDef['operator']) && !empty($value) && $value!=="null")) {
        if (!empty($joinDef['sql']))
          $joins[] = $joinDef['sql'];
        elseif (!empty($joinDef['standard_join']) && !in_array($joinDef['standard_join'], $this->doneStandardParamJoins)) {
          // a parameter can reference a standard join, so that several params can share 1 join to a table rather than
          // join to it multiple times.
          switch ($joinDef['standard_join']) {
            case 'prefcttl':
              $joins[] = "JOIN cache_taxa_taxon_lists prefcttl ON prefcttl.id=o.preferred_taxa_taxon_list_id";
              break;
            default:
              throw new exception("Unrecognised standard join refered to by report parameter: $joinDef[standard_join]");
          }
          $this->doneStandardParamJoins[] = $joinDef['standard_join'];
        }
      }
    }
    // put the param joins after the #joins# token, as we might insert other joins first that are required by the param joins,
    // e.g. the sample table when doing geometry autoswitching.
    $query = str_replace('#joins#', "#joins#\n".implode("\n", $joins), $query);
    return $query;
  }

  /**
   * Add any where clause filters defined by a used parameter to the query.
   * @todo: Consider caching of the preprocess output.
   */
  private function addParamWheres($query, $paramName, $paramDef, $value) {
    if ($value && isset($paramDef['custom']) && $paramDef['custom']==='unique_location_index') {
      // special case for this parameter when the location is a unique indexed location type,
      // since we can use a more effective where clause instead of the join.
      $typeTerm = $this->locationIdUniquelyIndexedType($value);
      if ($typeTerm)
        foreach($paramDef['wheres'] as &$whereDef) {
          $whereDef['sql'] = str_replace('#typealias#', strtolower(str_replace(' ', '_', $typeTerm)), $whereDef['sql']);
        }
      else
        return $query;
    }
    foreach($paramDef['wheres'] as $whereDef) {
      if ((!empty($whereDef['operator']) && (($whereDef['operator']==='equal' && $whereDef['value']===$value) ||
          ($whereDef['operator']==='notequal' && $whereDef['value']!==$value)))
          // operator not provided, so default is to join if param not empty (null string passed for empty integers)
          || (empty($whereDef['operator']) && !empty($value) && $value!=="null")) {
        // Join SQL can contain the parameter value as well.
        $query = str_replace('#filters#', "AND $whereDef[sql]\n#filters#", $query);
      }
    }
    return $query;
  }

  /**
   * If sorting on the date column (the extra column added by vague date processing) then
   * switch the sort order back to use date_start.
   */
  private function checkOrderByForVagueDate($order_by) {
    $order_by = trim($order_by);
    if ($this->getVagueDateProcessing() && !empty($order_by)) {
      $this->prepareColumns();
      $cols = array_keys($this->columns);
      // Find if we have a date_start column to switch date sort fields to.
      for ($i=0; $i<count($cols); $i++) {
        if (substr(($cols[$i]), -10) == 'date_start') {
          // got a date_start field available in the cols, so switch any date sort fields over
          $sortfields = explode(',', $order_by);
          $prefix=substr($cols[$i], 0, strlen($cols[$i])-10);
          foreach ($sortfields as &$field) {
            $tokens = explode(' ', $field);
            if ($tokens[0]===$prefix.'date') {
              $tokens[0] = $cols[$i];
              $field = implode(' ', $tokens);
            }
          }
          $order_by = implode(',', $sortfields);
          break;
        }
      }
    }
    return $order_by;
  }

  private function executeQuery()
  {
    $tm = microtime(true);
    $this->response = $this->reportDb->query($this->query);
    $tm = microtime(true) - $tm;
    if ($tm>5) {
      kohana::log('alert', "Report query took $tm seconds.");
      kohana::log('alert', $this->report);
      kohana::log('alert', $this->query);
    } else {
      Kohana::log('debug', "Run report query : ".$this->query);
    }
  }

}