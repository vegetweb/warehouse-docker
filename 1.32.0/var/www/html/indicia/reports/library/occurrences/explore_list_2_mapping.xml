<report
    title="Explore records 2 mapping"
    description="Report designed for the explore records mapping facility in iRecord, with additional parameters. 
        Uses a spatial intersection to determine the records in the supplied boundary."
>
  <query website_filter_field="o.website_id" samples_id_field="o.sample_id">
  SELECT #columns#
  FROM cache_occurrences_functional o
  JOIN cache_occurrences_nonfunctional onf on onf.id=o.id
  JOIN cache_samples_nonfunctional snf on snf.id=o.sample_id
  JOIN cache_taxa_taxon_lists cttl ON cttl.id=o.taxa_taxon_list_id
  #agreements_join#
  #joins#
  WHERE #sharing_filter# 
  AND o.record_status not in ('I','T') AND (#ownData#=1 OR o.record_status not in ('D','R'))
  #idlist#
  </query>
  <params>
    <param name="smpattrs" display="Sample attribute list" description="Comma separated list of sample attribute IDs to include" datatype="smpattrs" />
    <param name="occattrs" display="Occurrence attribute list" description="Comma separated list of occurrence attribute IDs to include" datatype="occattrs" />
    <param name="searchArea" display="Report Search Area" datatype="geometry" allow_buffer="true">
      <where>st_intersects(o.public_geom, ST_MakeValid(st_geomfromtext('#searchArea#',900913)))</where>
    </param>
    <param name="idlist" display="List of IDs" description="Comma separated list of occurrence IDs to filter to." datatype="idlist" fieldname="o.id" alias="occurrence_id" />
    <param name="currentUser" display="Current User ID" description="Current user's warehouse ID. Allows a column to be output indicating that the user owns the record." datatype="text" />
    <param name="ownData" display="My data only?" datatype="checkbox">
      <where value="1">o.created_by_id=#currentUser#</where>
    </param>
    <param name="location_id" display="Location" description="Provide the location to display records for" datatype="lookup" emptyvalue="0"
        population_call="direct:location:id:name" />
    <param name="ownLocality" display="My locality only?" datatype="checkbox">
      <join value="1">JOIN locations lfilter ON st_intersects(coalesce(lfilter.boundary_geom, lfilter.centroid_geom), o.public_geom) AND lfilter.id=#location_id#</join>  
    </param>
    <param name="taxon_groups" display="Taxon Groups" description="List of taxon group IDs to view data for" datatype="integer[]" emptyvalue="0"/>
    <param name="ownGroups" display="My species groups only?" datatype="checkbox">      
      <where value="1">o.taxon_group_id IN (#taxon_groups#)</where>
    </param>
    <param name="survey_id" display="Survey" description="Select the survey, or leave for all surveys" datatype="lookup"
        population_call="direct:survey:id:title">
      <where>o.survey_id=#survey_id#</where>
    </param>
    <param name="date_from" display="Date From" datatype="date">
      <where>('#date_from#'='Click here' OR o.date_end &gt;= CAST(COALESCE('#date_from#','1500-01-01') as date))</where>
    </param>
    <param name="date_to" display="Date To" datatype="date">
      <where>('#date_to#'='Click here' OR o.date_start &lt;= CAST(COALESCE('#date_to#','1500-01-01') as date))</where>
    </param>
    <param name="input_form" default="">
      <where>o.input_form='#input_form#'</where>
    </param>
    <param name="taxon_meaning_id" default="">
      <where>o.taxon_meaning_id=#taxon_meaning_id#</where>
    </param>
  </params>
  <columns>
    <column name="occurrence_id" sql="o.id" on_demand="true" datatype="integer"/>
    <column name="source" sql="snf.website_title || ' | ' || snf.survey_title" on_demand="true" datatype="text"/>
    <column name="sample_id" sql="o.sample_id" on_demand="true" datatype="integer"/>
    <column name="taxon" on_demand="true" datatype="text"
      sql="CASE WHEN cttl.preferred_taxon=cttl.default_common_name then cttl.preferred_taxon ELSE cttl.preferred_taxon || COALESCE(' | ' || cttl.default_common_name, '') END" />
    <column name="taxon_group" sql="cttl.taxon_group" on_demand="true" datatype="text"/>
    <column name="taxa_taxon_list_id" sql="o.taxa_taxon_list_id" on_demand="true" datatype="integer"/>   
    <column name="location_name" sql="o.location_name" on_demand="true" datatype="text"/>
    <column name="entered_sref" sql="regexp_replace(snf.public_entered_sref, ',[^ ]', ', ', 'g')" on_demand="true" datatype="text"/>
    <column name="sref" sql="snf.public_entered_sref" on_demand="true" in_count="true" datatype="text"/>
    <column name="sref_system" sql="snf.entered_sref_system" on_demand="true" in_count="true" datatype="text"/>
    <column name="date_start" sql="o.date_start" on_demand="true"/>
    <column name="date_end" sql="o.date_end" on_demand="true"/>
    <column name="date_type" sql="o.date_type" on_demand="true"/>
    <column name="recorder" sql="CASE WHEN o.website_id IN (#website_ids#) THEN '' ELSE snf.website_title || '-&gt; ' END || CASE WHEN LENGTH(snf.recorders)>30 THEN 'Recorder' ELSE snf.recorders END"
        on_demand="true" datatype="text" />
    <column name="zero_abundance" sql="o.zero_abundance" on_demand="true" datatype="integer"/>
    <column name="record_status" sql="o.record_status" on_demand="true" in_count="true" datatype="text"/>
    <column name="certainty" sql="o.certainty" on_demand="true" in_count="true" datatype="text"/>    
    <column name="fo" visible="false" feature_style="fillOpacity" sql="0.2+sqrt(count(o.id)::float-1)/20" aggregate="true" />
    <column name="sc" visible="false" feature_style="strokeColor" sql="case o.record_status when 'C' then 
      case o.certainty when 'C' then 'green' when 'L' then 'orange' when 'U' then '#800000' else 'blue' end
    when 'V' then 'green'
    when 'D' then 'orange'
    when 'R' then '#800000'
    else 'black' end" internal_sql="o.certainty" />
    <column name="fc" visible="false" feature_style="fillColor" sql="case o.record_status when 'V' then 'green' when 'D' then 'orange' when 'R' then '#800000' else 'blue' end"
        internal_sql="o.record_status"/>
    <column name="geom" visible="false" mappable="true" sql="st_astext(o.public_geom)" />
    <column name="occurrence_ids" visible="false" sql="array_to_string(array_agg(o.id), ',')" aggregate="true" />
    <column name="taxon_meaning_ids" visible="false" sql="array_to_string(array_agg(distinct o.taxon_meaning_id), ',')" aggregate="true" />
  </columns>
</report>